Mira este es mi proyecto, tengo mi backend y frontend, sino que quisiera que verificaran que esta mal, que puede estar dando errores y demas cosas, tambien que se pued mejorr, la idea general es obviamente implementar las funciones del backend como el CRUD y demas y tambien algo que tu quieras, algo como innovador que se puedaimplementar, me gsutaria que me ayudaras
proyectoElectiva/
│
├── config/
│   └── connect-db.mjs                 # Configuración de MongoDB
│
├── controllers/
│   ├── controller-auth.mjs            # Lógica de autenticación
│   ├── controller-driver.mjs          # Lógica de conductores
│   └── controller-trips.mjs           # Lógica de viajes
│
├── middlewares/
│   ├── auth.mjs                       # Middleware de autenticación JWT
│   └── errorHandler.mjs               # Manejo centralizado de errores
│
├── models/
│   ├── Driver.mjs                     # Esquema de Conductor
│   └── Trip.mjs                       # Esquema de Viaje
│
├── routes/
│   ├── auth-routes.mjs                # Rutas de autenticación
│   ├── driver-routes.mjs              # Rutas de conductores
│   └── trip-routes.mjs                # Rutas de viajes
│
├── utils/
│   └── ratingCalculator.mjs           # Utilidades para ratings
│
├── .env                               # Variables de entorno
├── .gitignore                         # Archivos ignorados por Git
├── package.json                       # Dependencias del proyecto
├── server.mjs                         # Punto de entrada de la aplicación
│
├── DiagramaDeClases.png               # Diagrama de clases UML
├── DiagramaDeComponentes.png          # Diagrama de componentes
└── README.md                          # Documentación del proyecto
connect-db.mjs
import mongoose from "mongoose";

const URL = "mongodb+srv://admin:123@clustertest.zzdjvmf.mongodb.net/driver_trip_db";

const connectDB = async () => {
    try {
        await mongoose.connect(URL);
        console.log('MongoDB Connected to: driver_trip_db');
    } catch (error) {
        console.error('Error connecting to MongoDB:', error.message);
        process.exit(1);
    }
};

export default connectDB;

controllers/controller-auth.mjs
import { generateToken } from '../middlewares/auth.mjs';
import Driver from '../models/Driver.mjs';

// Login de conductor
export async function login(req, res) {
    try {
        const { email, license_number } = req.body;

        if (!email || !license_number) {
            return res.status(400).json({
                success: false,
                message: 'Email y número de licencia son obligatorios'
            });
        }

        const driver = await Driver.findOne({ email, license_number });

        if (!driver) {
            return res.status(401).json({
                success: false,
                message: 'Credenciales inválidas'
            });
        }

        
        const token = generateToken({ 
            id: driver._id.toString(), 
            email: driver.email,
            name: driver.name
        });

        res.status(200).json({
            success: true,
            message: 'Login exitoso',
            token,
            driver: {
                id: driver._id,
                name: driver.name,
                email: driver.email,
                phone: driver.phone,
                license_number: driver.license_number,
                rating: driver.rating,
                status: driver.status
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Error en login',
            error: error.message
        });
    }
}

// Verificar token 
export async function verifyToken(req, res) {
    try {
        // El middleware ya verificó el token y agregó req.user
        const driver = await Driver.findById(req.user.id);
        
        if (!driver) {
            return res.status(404).json({
                success: false,
                message: 'Conductor no encontrado'
            });
        }

        res.status(200).json({
            success: true,
            message: 'Token válido',
            driver: {
                id: driver._id,
                name: driver.name,
                email: driver.email,
                phone: driver.phone,
                license_number: driver.license_number,
                rating: driver.rating,
                status: driver.status
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Error al verificar token',
            error: error.message
        });
    }
}

//  OPCIONAL: Función de registro si quieres permitir auto-registro de conductores
export async function register(req, res) {
    try {
      const { name, email, phone, license_number, vehicle_type, vehicle_plate, vehicle_capacity } = req.body;
      
      // Validación
      if (!name || !email || !phone || !license_number) {
        return res.status(400).json({
          success: false,
          message: 'Todos los campos son obligatorios'
        });
      }
  
      // Verificar si ya existe
      const existingDriver = await Driver.findOne({
        $or: [{ email }, { license_number }]
      });
  
      if (existingDriver) {
        return res.status(400).json({
          success: false,
          message: 'El email o número de licencia ya están registrados'
        });
      }
  
      // Crear nuevo conductor
      const newDriver = new Driver({
        name,
        email,
        phone,
        license_number,
        vehicle_type,
        vehicle_plate,
        vehicle_capacity
      });
  
      const savedDriver = await newDriver.save();
  
      // Generar token
      const token = generateToken({
        id: savedDriver._id.toString(),
        email: savedDriver.email,
        name: savedDriver.name
      });
  
      res.status(201).json({
        success: true,
        message: 'Conductor registrado exitosamente',
        token,
        driver: {
          id: savedDriver._id,
          name: savedDriver.name,
          email: savedDriver.email,
          phone: savedDriver.phone,
          license_number: savedDriver.license_number,
          vehicle_type: savedDriver.vehicle_type,
          vehicle_plate: savedDriver.vehicle_plate,
          vehicle_capacity: savedDriver.vehicle_capacity
        }
      });
    } catch (error) {
      if (error.name === 'ValidationError') {
        return res.status(400).json({
          success: false,
          message: 'Error de validación',
          errors: Object.values(error.errors).map(err => err.message)
        });
      }
      res.status(500).json({
        success: false,
        message: 'Error al registrar conductor',
        error: error.message
      });
    }
  }
  

  controllers/controller-driver.mjs

import Driver from '../models/Driver.mjs';

// Obtener todos los conductores
async function findAll(req, res) {
    try {
        const drivers = await Driver.find();
        res.status(200).json({
            success: true,
            data: drivers,
            total: drivers.length
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error retrieving drivers",
            error: error.message
        });
    }
}

// Obtener conductor por ID
async function findById(req, res) {
    try {
        const driver = await Driver.findById(req.params.id);
        
        if (!driver) {
            return res.status(404).json({
                success: false,
                message: "Driver not found"
            });
        }
        
        res.status(200).json({
            success: true,
            data: driver
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error retrieving driver",
            error: error.message
        });
    }
}

// ✅ CORREGIDO: Crear conductor con validación y campos completos
async function save(req, res) {
    try {
        const { 
            name, 
            email, 
            phone, 
            license_number,
            vehicle_type,
            vehicle_plate,
            vehicle_capacity 
        } = req.body;
        
        // Validación de campos requeridos
        if (!name || !email || !phone || !license_number) {
            return res.status(400).json({
                success: false,
                message: "Name, email, phone and license_number are required"
            });
        }

        // Verificar si ya existe
        const existingDriver = await Driver.findOne({
            $or: [{ email }, { license_number: license_number.toUpperCase() }]
        });

        if (existingDriver) {
            return res.status(400).json({
                success: false,
                message: "Driver with this email or license number already exists"
            });
        }
        
        // Crear nuevo conductor con TODOS los campos
        const newDriver = new Driver({
            name: name.trim(),
            email: email.toLowerCase().trim(),
            phone: phone.trim(),
            license_number: license_number.toUpperCase().trim(),
            vehicle_type: vehicle_type || 'sedan',
            vehicle_plate: vehicle_plate ? vehicle_plate.toUpperCase().trim() : undefined,
            vehicle_capacity: vehicle_capacity || 4
        });
        
        const savedDriver = await newDriver.save();
        
        res.status(201).json({
            success: true,
            message: "Driver created successfully",
            data: savedDriver
        });
    } catch (error) {
        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                message: "Validation error",
                errors: Object.values(error.errors).map(err => err.message)
            });
        }
        
        if (error.code === 11000) {
            return res.status(400).json({
                success: false,
                message: "Driver with this email or license number already exists"
            });
        }
        
        res.status(500).json({
            success: false,
            message: "Error creating driver",
            error: error.message
        });
    }
}

// ✅ CORREGIDO: Actualizar con todos los campos
async function update(req, res) {
    try {
        const { 
            name, 
            email, 
            phone, 
            license_number, 
            rating, 
            status,
            vehicle_type,
            vehicle_plate,
            vehicle_capacity 
        } = req.body;
        
        // Preparar objeto de actualización solo con campos proporcionados
        const updateData = {};
        if (name) updateData.name = name.trim();
        if (email) updateData.email = email.toLowerCase().trim();
        if (phone) updateData.phone = phone.trim();
        if (license_number) updateData.license_number = license_number.toUpperCase().trim();
        if (rating !== undefined) updateData.rating = rating;
        if (status) updateData.status = status;
        if (vehicle_type) updateData.vehicle_type = vehicle_type;
        if (vehicle_plate) updateData.vehicle_plate = vehicle_plate.toUpperCase().trim();
        if (vehicle_capacity) updateData.vehicle_capacity = vehicle_capacity;
        
        const updatedDriver = await Driver.findByIdAndUpdate(
            req.params.id,
            updateData,
            { new: true, runValidators: true }
        );
        
        if (!updatedDriver) {
            return res.status(404).json({
                success: false,
                message: "Driver not found"
            });
        }
        
        res.status(200).json({
            success: true,
            message: "Driver updated successfully",
            data: updatedDriver
        });
    } catch (error) {
        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                message: "Validation error",
                errors: Object.values(error.errors).map(err => err.message)
            });
        }
        
        if (error.code === 11000) {
            return res.status(400).json({
                success: false,
                message: "Email or license number already exists"
            });
        }
        
        res.status(500).json({
            success: false,
            message: "Error updating driver",
            error: error.message
        });
    }
}

// Eliminar conductor
async function remove(req, res) {
    try {
        const deletedDriver = await Driver.findByIdAndDelete(req.params.id);
        
        if (!deletedDriver) {
            return res.status(404).json({
                success: false,
                message: "Driver not found"
            });
        }
        
        res.status(200).json({
            success: true,
            message: "Driver deleted successfully",
            data: deletedDriver
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error deleting driver",
            error: error.message
        });
    }
}

export {
    findAll,
    findById, remove, save,
    update
};

controllers/controller-trips.mjs

import Driver from '../models/Driver.mjs';
import Trip from '../models/Trip.mjs';
import { calculateAverageRating, validateRating } from '../utils/ratingCalculator.mjs';

// Obtener todos los viajes
async function findAll(req, res) {
    try {
        const { status, driver_id } = req.query;
        
        // Filtros opcionales
        const filter = {};
        if (status) filter.status = status;
        if (driver_id) filter.driver_id = driver_id;
        
        const trips = await Trip.find(filter)
            .populate('driver_id', 'name email phone rating license_number')
            .sort({ departure_time: -1 }); // Ordenar por fecha más reciente
        
        res.status(200).json({
            success: true,
            data: trips,
            total: trips.length
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error al obtener los viajes",
            error: error.message
        });
    }
}

// Obtener un viaje por ID
async function findById(req, res) {
    try {
        const trip = await Trip.findById(req.params.id)
            .populate('driver_id', 'name email phone rating license_number status');
        
        if (!trip) {
            return res.status(404).json({
                success: false,
                message: "Viaje no encontrado"
            });
        }
        
        res.status(200).json({
            success: true,
            data: trip
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error al obtener el viaje",
            error: error.message
        });
    }
}

// Crear un nuevo viaje
async function save(req, res) {
    try {
        const { 
            driver_id, 
            origin, 
            destination, 
            departure_time, 
            price, 
            available_seats,
            distance_km,
            duration_minutes
        } = req.body;
        
        // Verificar que el conductor existe
        const driver = await Driver.findById(driver_id);
        if (!driver) {
            return res.status(404).json({
                success: false,
                message: "Conductor no encontrado"
            });
        }
        
        // Verificar que el conductor esté disponible
        if (driver.status !== 'available') {
            return res.status(400).json({
                success: false,
                message: `El conductor no está disponible. Estado actual: ${driver.status}`
            });
        }
        
        // Crear el nuevo viaje
        const newTrip = new Trip({
            driver_id,
            origin,
            destination,
            departure_time,
            price,
            available_seats: available_seats || 4,
            distance_km,
            duration_minutes
        });
        
        const savedTrip = await newTrip.save();
        
        // Actualizar el estado del conductor a 'busy'
        driver.status = 'busy';
        await driver.save();
        
        // Incrementar el contador de viajes del conductor
        await driver.incrementTrips();
        
        const populatedTrip = await Trip.findById(savedTrip._id)
            .populate('driver_id', 'name email phone rating');
        
        res.status(201).json({
            success: true,
            message: "Viaje creado exitosamente",
            data: populatedTrip
        });
    } catch (error) {
        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                message: "Error de validación",
                errors: Object.values(error.errors).map(err => err.message)
            });
        }
        
        res.status(500).json({
            success: false,
            message: "Error al crear el viaje",
            error: error.message
        });
    }
}

// Actualizar un viaje
async function update(req, res) {
    try {
        const { 
            driver_id, 
            origin, 
            destination, 
            departure_time, 
            arrival_time, 
            price, 
            available_seats, 
            status,
            distance_km,
            duration_minutes
        } = req.body;
        
        // Buscar el viaje actual
        const currentTrip = await Trip.findById(req.params.id);
        if (!currentTrip) {
            return res.status(404).json({
                success: false,
                message: "Viaje no encontrado"
            });
        }
        
        // Si se cambia el conductor, verificar que existe
        if (driver_id && driver_id !== currentTrip.driver_id.toString()) {
            const newDriver = await Driver.findById(driver_id);
            if (!newDriver) {
                return res.status(404).json({
                    success: false,
                    message: "Nuevo conductor no encontrado"
                });
            }
        }
        
        // Actualizar el viaje
        const updatedTrip = await Trip.findByIdAndUpdate(
            req.params.id,
            { 
                driver_id, 
                origin, 
                destination, 
                departure_time, 
                arrival_time, 
                price, 
                available_seats, 
                status,
                distance_km,
                duration_minutes
            },
            { new: true, runValidators: true }
        ).populate('driver_id', 'name email phone rating');
        
        // Si el viaje se completó, actualizar el estado del conductor a 'available'
        if (status === 'completed') {
            const driver = await Driver.findById(updatedTrip.driver_id);
            if (driver) {
                driver.status = 'available';
                await driver.save();
            }
        }
        
        res.status(200).json({
            success: true,
            message: "Viaje actualizado exitosamente",
            data: updatedTrip
        });
    } catch (error) {
        if (error.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                message: "Error de validación",
                errors: Object.values(error.errors).map(err => err.message)
            });
        }
        
        res.status(500).json({
            success: false,
            message: "Error al actualizar el viaje",
            error: error.message
        });
    }
}

// Eliminar un viaje
async function remove(req, res) {
    try {
        const deletedTrip = await Trip.findByIdAndDelete(req.params.id);
        
        if (!deletedTrip) {
            return res.status(404).json({
                success: false,
                message: "Viaje no encontrado"
            });
        }
        
        // Si el viaje estaba en progreso, liberar al conductor
        if (deletedTrip.status === 'in_progress' || deletedTrip.status === 'scheduled') {
            const driver = await Driver.findById(deletedTrip.driver_id);
            if (driver && driver.status === 'busy') {
                driver.status = 'available';
                await driver.save();
            }
        }
        
        res.status(200).json({
            success: true,
            message: "Viaje eliminado exitosamente",
            data: deletedTrip
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error al eliminar el viaje",
            error: error.message
        });
    }
}

// Agregar un pasajero a un viaje
async function addPassenger(req, res) {
    try {
        const { name, phone, seats_reserved } = req.body;
        
        if (!name || !phone || !seats_reserved) {
            return res.status(400).json({
                success: false,
                message: "Nombre, teléfono y número de asientos son obligatorios"
            });
        }
        
        const trip = await Trip.findById(req.params.id);
        
        if (!trip) {
            return res.status(404).json({
                success: false,
                message: "Viaje no encontrado"
            });
        }
        
        if (trip.status !== 'scheduled') {
            return res.status(400).json({
                success: false,
                message: "Solo se pueden agregar pasajeros a viajes programados"
            });
        }
        
        // Usar el método del modelo para agregar pasajero
        await trip.addPassenger({ name, phone, seats_reserved });
        
        const updatedTrip = await Trip.findById(trip._id)
            .populate('driver_id', 'name email phone');
        
        res.status(200).json({
            success: true,
            message: "Pasajero agregado exitosamente",
            data: updatedTrip
        });
    } catch (error) {
        res.status(400).json({
            success: false,
            message: error.message
        });
    }
}

// Calificar un viaje (actualiza el rating del conductor)
async function rateTrip(req, res) {
    try {
        const { rating } = req.body;
        
        // Validar el rating
        const validatedRating = validateRating(rating);
        
        const trip = await Trip.findById(req.params.id);
        
        if (!trip) {
            return res.status(404).json({
                success: false,
                message: "Viaje no encontrado"
            });
        }
        
        if (trip.status !== 'completed') {
            return res.status(400).json({
                success: false,
                message: "Solo se pueden calificar viajes completados"
            });
        }
        
        // Obtener el conductor
        const driver = await Driver.findById(trip.driver_id);
        
        if (!driver) {
            return res.status(404).json({
                success: false,
                message: "Conductor no encontrado"
            });
        }
        
        // Calcular nuevo rating del conductor
        // Fórmula: (rating_actual * total_viajes + nuevo_rating) / (total_viajes + 1)
        const currentTotal = driver.rating * Math.max(driver.total_trips - 1, 1);
        const newRating = calculateAverageRating([currentTotal, validatedRating]);
        
        driver.rating = newRating;
        await driver.save();
        
        res.status(200).json({
            success: true,
            message: "Viaje calificado exitosamente",
            data: {
                trip_id: trip._id,
                driver_id: driver._id,
                driver_name: driver.name,
                new_rating: newRating,
                rating_given: validatedRating
            }
        });
    } catch (error) {
        res.status(400).json({
            success: false,
            message: error.message
        });
    }
}

// Obtener estadísticas de viajes
async function getStatistics(req, res) {
    try {
        const { driver_id } = req.query;
        
        const filter = driver_id ? { driver_id } : {};
        
        const totalTrips = await Trip.countDocuments(filter);
        const completedTrips = await Trip.countDocuments({ ...filter, status: 'completed' });
        const scheduledTrips = await Trip.countDocuments({ ...filter, status: 'scheduled' });
        const inProgressTrips = await Trip.countDocuments({ ...filter, status: 'in_progress' });
        const cancelledTrips = await Trip.countDocuments({ ...filter, status: 'cancelled' });
        
        // Calcular ingresos totales de viajes completados
        const revenueData = await Trip.aggregate([
            { $match: { ...filter, status: 'completed' } },
            { $group: { _id: null, totalRevenue: { $sum: '$price' } } }
        ]);
        
        const totalRevenue = revenueData.length > 0 ? revenueData[0].totalRevenue : 0;
        
        res.status(200).json({
            success: true,
            data: {
                total_trips: totalTrips,
                completed: completedTrips,
                scheduled: scheduledTrips,
                in_progress: inProgressTrips,
                cancelled: cancelledTrips,
                total_revenue: totalRevenue,
                completion_rate: totalTrips > 0 ? ((completedTrips / totalTrips) * 100).toFixed(2) + '%' : '0%'
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error al obtener estadísticas",
            error: error.message
        });
    }
}

export {
    addPassenger, findAll,
    findById, getStatistics, rateTrip, remove, save,
    update
};


middlewares/auth.mjs

import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'secret-key';

export const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({
            success: false,
            message: 'Access token required'
        });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({
            success: false,
            message: 'Invalid or expired token'
        });
    }
};

export const generateToken = (payload) => {
    return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });
};

middlewares/errorHandler.mjs

export const errorHandler = (err, req, res, next) => {
    console.error('Error:', err);
    
    res.status(err.status || 500).json({
        success: false,
        message: err.message || 'Internal server error',
        error: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
};

export const notFound = (req, res, next) => {
    res.status(404).json({
        success: false,
        message: `Route ${req.originalUrl} not found`
    });
};

models/Driver.mjs
import mongoose from 'mongoose';

const driverSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'El nombre es obligatorio'],
    trim: true,
    minlength: [3, 'El nombre debe tener al menos 3 caracteres']
  },
  email: {
    type: String,
    required: [true, 'El email es obligatorio'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [/^\S+@\S+\.\S+$/, 'Por favor ingresa un email válido']
  },
  phone: {
    type: String,
    required: [true, 'El teléfono es obligatorio'],
    trim: true
  },
  license_number: {
    type: String,
    required: [true, 'El número de licencia es obligatorio'],
    unique: true,
    trim: true,
    uppercase: true
  },
  vehicle_type: {
    type: String,
    enum: ['sedan', 'suv', 'van', 'minibus'],
    default: 'sedan'
  },
  vehicle_plate: {
    type: String,
    trim: true,
    uppercase: true
  },
  vehicle_capacity: {
    type: Number,
    default: 4,
    min: 1,
    max: 20
  },
  rating: {
    type: Number,
    default: 5.0,
    min: 0,
    max: 5
  },
  status: {
    type: String,
    enum: ['available', 'busy', 'offline'],
    default: 'available'
  },
  total_trips: {
    type: Number,
    default: 0,
    min: 0
  }
}, {
  timestamps: true,
  versionKey: false
});

driverSchema.index({ email: 1 });
driverSchema.index({ license_number: 1 });

export default mongoose.model('Driver', driverSchema);
models/Trip.mjs

import mongoose from 'mongoose';

const tripSchema = new mongoose.Schema({
    driver_id: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Driver',
        required: [true, 'El ID del conductor es obligatorio']
    },
    origin: {
        type: String,
        required: [true, 'El origen es obligatorio'],
        trim: true
    },
    destination: {
        type: String,
        required: [true, 'El destino es obligatorio'],
        trim: true
    },
    departure_time: {
        type: Date,
        required: [true, 'La hora de salida es obligatoria']
    },
    arrival_time: {
        type: Date,
        default: null
    },
    price: {
        type: Number,
        required: [true, 'El precio es obligatorio'],
        min: [0, 'El precio no puede ser negativo']
    },
    available_seats: {
        type: Number,
        default: 4,
        min: [0, 'Los asientos disponibles no pueden ser negativos'],
        max: [8, 'El número máximo de asientos es 8']
    },
    status: {
        type: String,
        enum: {
            values: ['scheduled', 'in_progress', 'completed', 'cancelled'],
            message: '{VALUE} no es un estado válido'
        },
        default: 'scheduled'
    },
    passengers: [{
        name: {
            type: String,
            required: true
        },
        phone: {
            type: String,
            required: true
        },
        seats_reserved: {
            type: Number,
            default: 1,
            min: 1
        }
    }],
    distance_km: {
        type: Number,
        min: [0, 'La distancia no puede ser negativa']
    },
    duration_minutes: {
        type: Number,
        min: [0, 'La duración no puede ser negativa']
    }
}, {
    timestamps: true,  // Agrega createdAt y updatedAt automáticamente
    versionKey: false  // Elimina el campo __v
});

// Índices para mejorar búsquedas
tripSchema.index({ driver_id: 1 });
tripSchema.index({ status: 1 });
tripSchema.index({ departure_time: 1 });

// Método virtual para calcular asientos ocupados
tripSchema.virtual('occupied_seats').get(function() {
    if (!this.passengers || this.passengers.length === 0) {
        return 0;
    }
    return this.passengers.reduce((total, passenger) => total + passenger.seats_reserved, 0);
});

// Método virtual para verificar disponibilidad
tripSchema.virtual('is_available').get(function() {
    return this.available_seats > 0 && this.status === 'scheduled';
});

// Método para agregar un pasajero
tripSchema.methods.addPassenger = async function(passengerData) {
    if (this.available_seats < passengerData.seats_reserved) {
        throw new Error('No hay suficientes asientos disponibles');
    }
    
    this.passengers.push(passengerData);
    this.available_seats -= passengerData.seats_reserved;
    
    return await this.save();
};

// Middleware pre-save para validaciones adicionales
tripSchema.pre('save', function(next) {
    // Validar que la fecha de salida no sea en el pasado (solo para nuevos documentos)
    if (this.isNew && this.departure_time < new Date()) {
        next(new Error('La hora de salida no puede ser en el pasado'));
    }
    
    // Validar que arrival_time sea después de departure_time
    if (this.arrival_time && this.arrival_time < this.departure_time) {
        next(new Error('La hora de llegada debe ser después de la hora de salida'));
    }
    
    next();
});

export default mongoose.model('Trip', tripSchema);

routes/auth-routes.mjs

import express from 'express';
import { login, register, verifyToken } from '../controllers/controller-auth.mjs';
import { authenticateToken } from '../middlewares/auth.mjs';

const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     LoginRequest:
 *       type: object
 *       required:
 *         - email
 *         - license_number
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *           example: juan.vargas40@uptc.edu.co
 *         license_number:
 *           type: string
 *           example: CD25442652
 *     RegisterRequest:
 *       type: object
 *       required:
 *         - name
 *         - email
 *         - phone
 *         - license_number
 *       properties:
 *         name:
 *           type: string
 *           example: Juan Pérez
 *         email:
 *           type: string
 *           format: email
 *           example: juan@example.com
 *         phone:
 *           type: string
 *           example: +57 300 1234567
 *         license_number:
 *           type: string
 *           example: ABC123456
 */

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Login de conductor
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginRequest'
 *     responses:
 *       200:
 *         description: Login exitoso
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Login exitoso
 *                 token:
 *                   type: string
 *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                 driver:
 *                   type: object
 *       401:
 *         description: Credenciales inválidas
 */
router.post('/login', login);

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Registrar nuevo conductor
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/RegisterRequest'
 *     responses:
 *       201:
 *         description: Conductor registrado exitosamente
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 token:
 *                   type: string
 *                 driver:
 *                   type: object
 *       400:
 *         description: Error de validación o conductor ya existe
 */
router.post('/register', register);

/**
 * @swagger
 * /api/auth/verify:
 *   get:
 *     summary: Verificar token JWT
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Token válido
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 driver:
 *                   type: object
 *       401:
 *         description: Token inválido o faltante
 *       404:
 *         description: Conductor no encontrado
 */
router.get('/verify', authenticateToken, verifyToken);

export default router;

routes/driver-routes.mjs

import express from 'express';
import { findAll, findById, remove, save, update } from '../controllers/controller-driver.mjs';
import { authenticateToken } from '../middlewares/auth.mjs';

const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Driver:
 *       type: object
 *       required:
 *         - name
 *         - email
 *         - phone
 *         - license_number
 *       properties:
 *         _id:
 *           type: string
 *           description: ID autogenerado del conductor
 *         name:
 *           type: string
 *           description: Nombre completo del conductor
 *           example: Juan Pérez
 *         email:
 *           type: string
 *           format: email
 *           description: Email del conductor
 *           example: juan@example.com
 *         phone:
 *           type: string
 *           description: Teléfono del conductor
 *           example: +57 300 1234567
 *         license_number:
 *           type: string
 *           description: Número de licencia de conducir
 *           example: ABC123456
 *         rating:
 *           type: number
 *           format: float
 *           minimum: 0
 *           maximum: 5
 *           description: Calificación del conductor
 *           example: 4.5
 *         status:
 *           type: string
 *           enum: [available, busy, offline]
 *           description: Estado actual del conductor
 *           example: available
 *         total_trips:
 *           type: number
 *           description: Número total de viajes realizados
 *           example: 25
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/drivers:
 *   get:
 *     summary: Obtener todos los conductores
 *     tags: [Drivers]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de conductores
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Driver'
 *                 total:
 *                   type: number
 *       401:
 *         description: No autorizado - Token inválido o faltante
 */
router.get('/', authenticateToken, findAll);

/**
 * @swagger
 * /api/drivers/{id}:
 *   get:
 *     summary: Obtener conductor por ID
 *     tags: [Drivers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ID del conductor
 *     responses:
 *       200:
 *         description: Conductor encontrado
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   $ref: '#/components/schemas/Driver'
 *       404:
 *         description: Conductor no encontrado
 *       401:
 *         description: No autorizado
 */
router.get('/:id', authenticateToken, findById);

/**
 * @swagger
 * /api/drivers:
 *   post:
 *     summary: Crear un nuevo conductor
 *     tags: [Drivers]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - email
 *               - phone
 *               - license_number
 *             properties:
 *               name:
 *                 type: string
 *                 example: Carlos Rodríguez
 *               email:
 *                 type: string
 *                 format: email
 *                 example: carlos@example.com
 *               phone:
 *                 type: string
 *                 example: +57 310 9876543
 *               license_number:
 *                 type: string
 *                 example: XYZ789012
 *     responses:
 *       201:
 *         description: Conductor creado exitosamente
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Driver'
 *       400:
 *         description: Error de validación
 *       401:
 *         description: No autorizado
 */
router.post('/', authenticateToken, save);

/**
 * @swagger
 * /api/drivers/{id}:
 *   put:
 *     summary: Actualizar conductor
 *     tags: [Drivers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ID del conductor
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               phone:
 *                 type: string
 *               license_number:
 *                 type: string
 *               rating:
 *                 type: number
 *                 minimum: 0
 *                 maximum: 5
 *               status:
 *                 type: string
 *                 enum: [available, busy, offline]
 *             example:
 *               status: busy
 *               rating: 4.8
 *     responses:
 *       200:
 *         description: Conductor actualizado exitosamente
 *       404:
 *         description: Conductor no encontrado
 *       401:
 *         description: No autorizado
 */
router.put('/:id', authenticateToken, update);

/**
 * @swagger
 * /api/drivers/{id}:
 *   delete:
 *     summary: Eliminar conductor
 *     tags: [Drivers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ID del conductor
 *     responses:
 *       200:
 *         description: Conductor eliminado exitosamente
 *       404:
 *         description: Conductor no encontrado
 *       401:
 *         description: No autorizado
 */
router.delete('/:id', authenticateToken, remove);

export default router;

routes/trip-routes.mjs

import express from 'express';
import {
    addPassenger,
    findAll,
    findById,
    getStatistics,
    rateTrip,
    remove,
    save,
    update
} from '../controllers/controller-trips.mjs';
import { authenticateToken } from '../middlewares/auth.mjs';

const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Trip:
 *       type: object
 *       required:
 *         - driver_id
 *         - origin
 *         - destination
 *         - departure_time
 *         - price
 *       properties:
 *         _id:
 *           type: string
 *         driver_id:
 *           type: string
 *           description: ID del conductor
 *         origin:
 *           type: string
 *           example: Bogotá
 *         destination:
 *           type: string
 *           example: Fusagasugá
 *         departure_time:
 *           type: string
 *           format: date-time
 *           example: 2025-10-15T08:00:00Z
 *         arrival_time:
 *           type: string
 *           format: date-time
 *         price:
 *           type: number
 *           example: 25000
 *         available_seats:
 *           type: number
 *           example: 4
 *         status:
 *           type: string
 *           enum: [scheduled, in_progress, completed, cancelled]
 *           example: scheduled
 *         distance_km:
 *           type: number
 *           example: 65
 *         duration_minutes:
 *           type: number
 *           example: 90
 *         passengers:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               phone:
 *                 type: string
 *               seats_reserved:
 *                 type: number
 */

/**
 * @swagger
 * /api/trips:
 *   get:
 *     summary: Obtener todos los viajes
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [scheduled, in_progress, completed, cancelled]
 *         description: Filtrar por estado
 *       - in: query
 *         name: driver_id
 *         schema:
 *           type: string
 *         description: Filtrar por conductor
 *     responses:
 *       200:
 *         description: Lista de viajes
 *       401:
 *         description: No autorizado
 */
router.get('/', authenticateToken, findAll);

/**
 * @swagger
 * /api/trips/statistics:
 *   get:
 *     summary: Obtener estadísticas de viajes
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: driver_id
 *         schema:
 *           type: string
 *         description: Filtrar estadísticas por conductor
 *     responses:
 *       200:
 *         description: Estadísticas de viajes
 *       401:
 *         description: No autorizado
 */
router.get('/statistics', authenticateToken, getStatistics);

/**
 * @swagger
 * /api/trips/{id}:
 *   get:
 *     summary: Obtener viaje por ID
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Viaje encontrado
 *       404:
 *         description: Viaje no encontrado
 */
router.get('/:id', authenticateToken, findById);

/**
 * @swagger
 * /api/trips:
 *   post:
 *     summary: Crear un nuevo viaje
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - driver_id
 *               - origin
 *               - destination
 *               - departure_time
 *               - price
 *             properties:
 *               driver_id:
 *                 type: string
 *                 example: 507f1f77bcf86cd799439011
 *               origin:
 *                 type: string
 *                 example: Bogotá
 *               destination:
 *                 type: string
 *                 example: Fusagasugá
 *               departure_time:
 *                 type: string
 *                 format: date-time
 *                 example: 2025-10-15T08:00:00Z
 *               price:
 *                 type: number
 *                 example: 25000
 *               available_seats:
 *                 type: number
 *                 example: 4
 *               distance_km:
 *                 type: number
 *                 example: 65
 *               duration_minutes:
 *                 type: number
 *                 example: 90
 *     responses:
 *       201:
 *         description: Viaje creado exitosamente
 *       400:
 *         description: Error de validación
 */
router.post('/', authenticateToken, save);

/**
 * @swagger
 * /api/trips/{id}:
 *   put:
 *     summary: Actualizar viaje
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [scheduled, in_progress, completed, cancelled]
 *               arrival_time:
 *                 type: string
 *                 format: date-time
 *             example:
 *               status: completed
 *               arrival_time: 2025-10-15T09:30:00Z
 *     responses:
 *       200:
 *         description: Viaje actualizado
 *       404:
 *         description: Viaje no encontrado
 */
router.put('/:id', authenticateToken, update);

/**
 * @swagger
 * /api/trips/{id}:
 *   delete:
 *     summary: Eliminar viaje
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Viaje eliminado
 *       404:
 *         description: Viaje no encontrado
 */
router.delete('/:id', authenticateToken, remove);

/**
 * @swagger
 * /api/trips/{id}/passengers:
 *   post:
 *     summary: Agregar pasajero al viaje
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - phone
 *               - seats_reserved
 *             properties:
 *               name:
 *                 type: string
 *                 example: María González
 *               phone:
 *                 type: string
 *                 example: +57 310 9876543
 *               seats_reserved:
 *                 type: number
 *                 example: 2
 *     responses:
 *       200:
 *         description: Pasajero agregado
 *       400:
 *         description: No hay asientos disponibles
 */
router.post('/:id/passengers', authenticateToken, addPassenger);

/**
 * @swagger
 * /api/trips/{id}/rate:
 *   post:
 *     summary: Calificar viaje
 *     tags: [Trips]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - rating
 *             properties:
 *               rating:
 *                 type: number
 *                 minimum: 0
 *                 maximum: 5
 *                 example: 4.5
 *     responses:
 *       200:
 *         description: Viaje calificado exitosamente
 *       400:
 *         description: Solo se pueden calificar viajes completados
 */
router.post('/:id/rate', authenticateToken, rateTrip);

export default router;

server.mjs

import cors from 'cors';
import express from 'express';
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';
import connectDB from './config/connect-db.mjs';
import { errorHandler, notFound } from './middlewares/errorHandler.mjs';
import authRoutes from './routes/auth-routes.mjs';
import driverRoutes from './routes/driver-routes.mjs';
import tripRoutes from './routes/trip-routes.mjs';

const app = express();
const PORT = process.env.PORT || 3000;

// Conectar a MongoDB
connectDB();

// Middlewares
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
// En server.mjs - Swagger configuration
const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Driver Trip API',
            version: '1.0.0',
            description: 'API RESTful para gestión de conductores y viajes',
        },
        servers: [
            // Servidor de producción
            {
                url: 'https://proyectoelectiva-pyl0.onrender.com',
                description: 'Production server (Render)'
            },
            // Servidor local (desarrollo)
            {
                url: 'http://localhost:3000',
                description: 'Development server'
            }
        ],
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT'
                }
            }
        },
        security: [{
            bearerAuth: []
        }]
    },
    apis: ['./routes/*.mjs']
};
const swaggerDocs = swaggerJsdoc(swaggerOptions);

// Personalizar Swagger UI
const swaggerUiOptions = {
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: 'Driver Trip API Documentation',
    swaggerOptions: {
        persistAuthorization: true,  // Mantener el token entre recargas
    }
};

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocs, swaggerUiOptions));

// Routes
app.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'Bienvenido a Driver Trip API',
        version: '1.0.0',
        documentation: '/api-docs',
        endpoints: {
            authentication: {
                login: 'POST /api/auth/login',
                register: 'POST /api/auth/register',
                verify: 'GET /api/auth/verify'
            },
            drivers: {
                list: 'GET /api/drivers',
                get: 'GET /api/drivers/:id',
                create: 'POST /api/drivers',
                update: 'PUT /api/drivers/:id',
                delete: 'DELETE /api/drivers/:id'
            },
            trips: {
                list: 'GET /api/trips',
                get: 'GET /api/trips/:id',
                create: 'POST /api/trips',
                update: 'PUT /api/trips/:id',
                delete: 'DELETE /api/trips/:id',
                addPassenger: 'POST /api/trips/:id/passengers',
                rate: 'POST /api/trips/:id/rate',
                statistics: 'GET /api/trips/statistics'
            }
        }
    });
});

app.use('/api/auth', authRoutes);
app.use('/api/drivers', driverRoutes);
app.use('/api/trips', tripRoutes);

// Error handlers
app.use(notFound);
app.use(errorHandler);

app.listen(PORT, () => {
    console.log(`🚀 Server running on port ${PORT}`);
    console.log(`📚 API Documentation: http://localhost:${PORT}/api-docs`);
    console.log(`🌍 Environment: ${process.env.NODE_ENV || 'development'}`);
});

export default app;



y este es mi frontend

